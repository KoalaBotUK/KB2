import abc
import copy
import json
import typing
from enum import Enum,  IntEnum
from functools import reduce
from types import UnionType
from typing import get_type_hints

from dislord.discord.reference import Missing
from dislord.types import ObjDict


def cast(obj, type_hint, param_name=None, client=None):
    # None
    if type_hint is None and (obj is None or obj is Missing):
        return obj

    # Missing
    if type_hint is Missing and (obj is None or obj is Missing):
        return obj

    if type_hint is None:
        # print("type_hint is None but obj is {}".format(obj))
        return obj

    if getattr(type_hint, '__origin__', None) == typing.Literal:
        if obj in type_hint.__args__:
            return obj
        else:
            raise ValueError(f"{obj} is not in {type_hint}")

    # Union
    if isinstance(type_hint, UnionType):
        errors = []
        for arg in type_hint.__args__:
            try:
                return cast(obj, arg, param_name, client)
            except Exception as err:
                errors.append(err)
        raise RuntimeError(f"None of the union type hints succeeded {errors} for {param_name}")

    # List
    if isinstance(type_hint, list):
        return list(obj)
    elif getattr(type_hint, '__origin__', None) is list:
        return [cast(o, type_hint.__args__[0], param_name, client) for o in obj]

    # Dict
    if isinstance(type_hint, dict):
        return dict(obj)
    elif getattr(type_hint, '__origin__', None) is dict:
        return {
            cast(ok, type_hint.__args__[0], param_name, client): cast(obj.get(ok), type_hint.__args__[1], ok,
                                                                      client)
            for ok in obj.keys()}

    # Literal
    if not isinstance(type_hint, type):
        if obj == type_hint:
            return obj
        else:
            raise RuntimeError(f"{param_name}={obj} is not equal to Literal {type_hint}")

    # BaseModel
    if issubclass(type_hint, BaseModel):
        return type_hint.from_dict(obj, client)

    if issubclass(type_hint, ObjDict):
        if not isinstance(obj, dict):
            raise TypeError(f"{type_hint} is not a dict")
        return type_hint(**{k: cast(v,
                                    get_type_hints(type_hint).get(k), k, client)
                            for k, v in obj.items()})

    # Enum, str, int, float
    if issubclass(type_hint, IntEnum):
        return type_hint(int(obj))

    if obj is not None and not isinstance(obj, Missing):
        return type_hint(obj)
    else:
        raise RuntimeError(f"{obj} cannot be converted to {type_hint}")


class AutoInitMeta(type):
    def __new__(cls, name, bases, dct):
        # Extract annotations (type hints)
        annotations = dct.get("__annotations__", {}) | reduce(lambda a, b: a | b,
                                                              [getattr(t, "__annotations__", {}) for t in bases], {})

        # Define the __init__ method
        def __init__(self, *args, **kwargs):
            for key, value in annotations.items():
                if key in kwargs:
                    setattr(self, key, kwargs[key])
                else:
                    setattr(self, key, None)

            # Assign positional arguments
            for key, arg in zip(annotations, args):
                setattr(self, key, arg)

        dct['__init__'] = __init__

        # Create the new class
        return super().__new__(cls, name, bases, dct)


class BaseModel(metaclass=AutoInitMeta):
    def __init__(self, *args, **kwargs):
        # Generated by metaclass
        pass

    @staticmethod
    @abc.abstractmethod
    def from_payload(payload: type[dict]) -> type['BaseModel']:
        pass

    @classmethod
    def from_dict(cls, env, client):
        type_hints = get_type_hints(cls)
        if cls == type(env):
            return env

        params = {}
        for p, hint in type_hints.items():
            if isinstance(env, dict):
                prop = env.get(p, Missing())
            else:
                prop = getattr(env, p, Missing())
            params[p] = cast(prop, hint, p)
        obj = cls(**params)  # noqa
        obj.client = client
        return obj

    @classmethod
    def from_kwargs(cls, *, client=None, **kwargs):
        return cls.from_dict(kwargs, client)

    def asdict(self, *, dict_factory=dict):
        """Return the fields of a dataclass instance as a new dictionary mapping
        field names to field values.

        Example usage::

                    class C:
              x: int
              y: int

          c = C(1, 2)
          assert asdict(c) == {'x': 1, 'y': 2}

        If given, 'dict_factory' will be used instead of built-in dict.
        The function applies recursively to field values that are
        dataclass instances. This will also look into built-in containers:
        tuples, lists, and dicts.
        """
        return BaseModel._asdict_inner(self, dict_factory)

    @staticmethod
    def _asdict_inner(obj, dict_factory):
        if obj is Missing:
            return None
        if isinstance(obj, BaseModel):
            result = []
            for name, value in obj.__annotations__.items():
                result.append((BaseModel._asdict_inner(name, dict_factory),
                               BaseModel._asdict_inner(getattr(obj, name), dict_factory)))
            return dict_factory(result)
        elif isinstance(obj, tuple) and hasattr(obj, '_fields'):
            # obj is a namedtuple.  Recurse into it, but the returned
            # object is another namedtuple of the same type.  This is
            # similar to how other list- or tuple-derived classes are
            # treated (see below), but we just need to create them
            # differently because a namedtuple's __init__ needs to be
            # called differently (see bpo-34363).

            # I'm not using namedtuple's _asdict()
            # method, because:
            # - it does not recurse in to the namedtuple fields and
            #   convert them to dicts (using dict_factory).
            # - I don't actually want to return a dict here.  The main
            #   use case here is json.dumps, and it handles converting
            #   namedtuples to lists.  Admittedly we're losing some
            #   information here when we produce a json list instead of a
            #   dict.  Note that if we returned dicts here instead of
            #   namedtuples, we could no longer call asdict() on a data
            #   structure where a namedtuple was used as a dict key.

            return type(obj)(*[BaseModel._asdict_inner(v, dict_factory) for v in obj])
        elif isinstance(obj, (list, tuple)):
            # Assume we can create an object of this type by passing in a
            # generator (which is not true for namedtuples, handled
            # above).
            return type(obj)(BaseModel._asdict_inner(v, dict_factory) for v in obj)
        elif isinstance(obj, dict):
            return type(obj)((BaseModel._asdict_inner(k, dict_factory),
                              BaseModel._asdict_inner(v, dict_factory))
                             for k, v in obj.items())
        else:
            return copy.deepcopy(obj)

    def __eq__(self, other):
        result = True
        for eq_attr in get_type_hints(self.__class__):
            self_attr = getattr(self, eq_attr, None)
            other_attr = getattr(other, eq_attr, None)
            result = result and compare_missing_none(self_attr, other_attr)
        return result


class EnhancedJSONEncoder(json.JSONEncoder):
    def default(self, o):
        if issubclass(type(o), ObjDict):
            return {k: self.default(v) for k, v in o.items()}
        if issubclass(type(o), BaseModel):
            return o.asdict()
        if issubclass(type(o), Enum):
            return o.value
        if o is Missing:
            return None
        if isinstance(o, list):
            return [self.default(v) for v in o]
        # if isinstance(o, type):
        return f"DEBUG: {o}"
        # return super().default(o)


def compare_missing_none(obj1, obj2):
    obj1_is_none_or_missing = obj1 is None or obj1 is Missing
    obj2_is_none_or_missing = obj2 is None or obj2 is Missing
    if obj1_is_none_or_missing and obj2_is_none_or_missing:
        return True
    else:
        if isinstance(obj1, Enum) and isinstance(obj2, Enum):
            return obj1.value == obj2.value
        else:
            return obj1.__eq__(obj2)


HexColor = type(int)
